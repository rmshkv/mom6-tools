{"timestamp": 1697565503.900601, "stored_source_code": "# Meridional Overturning\n\n`mom6_tools.moc` collection of functions for computing and plotting meridional overturning circulation. \n\nThe goal of this notebook is the following:\n\n1) server as an example on to compute a meridional overturning streamfunction (global and Atalntic) from CESM/MOM output; \n\n2) evaluate model experiments by comparing transports against observed estimates and other model results.\n\n%load_ext autoreload\n%autoreload 2\n%matplotlib inline\nimport matplotlib\nimport numpy as np\nimport xarray as xr\n# mom6_tools\nfrom mom6_tools.moc import  *\nfrom mom6_tools.DiagsCase import DiagsCase\nfrom ncar_jobqueue import NCARCluster\nfrom dask.distributed import Client\nfrom mom6_tools.m6toolbox import genBasinMasks, add_global_attrs \nimport matplotlib.pyplot as plt\nimport warnings, yaml, os, intake\nwarnings.filterwarnings(\"ignore\")\n# Read in the yaml file\ndiag_config_yml_path = \"diag_config.yml\"\ndiag_config_yml = yaml.load(open(diag_config_yml_path,'r'), Loader=yaml.Loader)\n\n# load avg dates\navg = diag_config_yml['Avg']\n\n# Create the case instance\ndcase = DiagsCase(diag_config_yml['Case'])\nDOUT_S = dcase.get_value('DOUT_S')\nif DOUT_S:\n  OUTDIR = dcase.get_value('DOUT_S_ROOT')+'/ocn/hist/'\nelse:\n  OUTDIR = dcase.get_value('RUNDIR')\n\nprint('Output directory is:', OUTDIR)\nprint('Casename is:', dcase.casename)\n# The following parameters must be set accordingly\n######################################################\n# add your name and email address below\nauthor = 'Gustavo Marques (gmarques@ucar.edu)'\n######################################################\n# create an empty class object\nclass args:\n  pass\n   \nargs.infile = OUTDIR\nargs.monthly = dcase.casename+diag_config_yml['Fnames']['z']\nargs.sigma2 = dcase.casename+diag_config_yml['Fnames']['rho2']\nargs.static = dcase.casename+diag_config_yml['Fnames']['static']\nargs.start_date = avg['start_date']\nargs.end_date = avg['end_date']\nargs.case_name = dcase.casename\nargs.label = ''\nargs.savefigs = False\n# read grid info\ngrd = MOM6grid(OUTDIR+'/'+args.static)\ntry:\n  depth = grd.depth_ocean\nexcept:\n  depth = grd.deptho\n# remove Nan's, otherwise genBasinMasks won't work\ndepth[np.isnan(depth)] = 0.0\nbasin_code = genBasinMasks(grd.geolon, grd.geolat, depth, verbose=False)\nbasin_code_xr = genBasinMasks(grd.geolon, grd.geolat, depth, verbose=False, xda=True)\ncluster = NCARCluster()\ncluster.scale(6)\nclient = Client(cluster)\nclient\ndef preprocess(ds):\n    variables = ['vmo','vhml','vhGM']\n    for v in variables:\n      if v not in ds.variables:\n        ds[v] = xr.zeros_like(ds.vo)\n    return ds[variables]\nprint('\\n Reading dataset...')\n# load data\n%time \nds = xr.open_mfdataset(OUTDIR+'/'+args.monthly, parallel=True, \\\n                             combine=\"nested\", concat_dim=\"time\", \\\n                             preprocess=preprocess).chunk({\"time\": 12})\nattrs =  {\n         'description': 'Annual mean meridional thickness flux by components ', \n         'reduction_method': 'annual mean weighted by days in each month',\n         'casename': dcase.casename\n         }\nds_ann =  m6toolbox.weighted_temporal_mean_vars(ds,attrs=attrs)\nprint('\\n Selecting data between {} and {}...'.format(args.start_date, args.end_date))\n%time ds_sel = ds_ann.sel(time=slice(args.start_date, args.end_date))\n### Compute temporal mean for each term\nstream = True\n# create a ndarray subclass\nclass C(np.ndarray): pass\nprint('\\n Computing time mean...')\n%time ds_mean = ds_sel.mean('time').compute()\n# create a ndarray subclass\nclass C(np.ndarray): pass\n\nif 'vmo' in ds.variables:\n  varName = 'vmo'; conversion_factor = 1.e-9\nelif 'vh' in ds.variables:\n  varName = 'vh'; conversion_factor = 1.e-6\n  if 'zw' in ds.variables: conversion_factor = 1.e-9 # Backwards compatible for when we had wrong units for 'vh'\nelse: raise Exception('Could not find \"vh\" or \"vmo\" in file \"%s\"'%(args.infile+args.monthly))\n  \ntmp = np.ma.masked_invalid(ds_sel[varName].mean('time').values)\ntmp = tmp[:].filled(0.)\nVHmod = tmp.view(C)\nVHmod.units = ds_sel[varName].units\n\nZmod = m6toolbox.get_z(ds, depth, varName)\n\nif args.case_name != '':  case_name = args.case_name + ' ' + args.label\nelse: case_name = rootGroup.title + ' ' + args.label\n## Global MOC\n%matplotlib inline\n\n# Global MOC\nm6plot.setFigureSize([16,9],576,debug=False)\naxis = plt.gca()\ncmap = plt.get_cmap('dunnePM')\nzg = Zmod.min(axis=-1); psiPlot = MOCpsi(VHmod)*conversion_factor\npsiPlot = 0.5 * (psiPlot[0:-1,:]+psiPlot[1::,:])\nyyg = grd.geolat_c[:,:].max(axis=-1)+0*zg\nci=m6plot.pmCI(0.,40.,5.)\nplotPsi(yyg, zg, psiPlot, ci, 'Global MOC [Sv]')\nplt.xlabel(r'Latitude [$\\degree$N]')\nplt.suptitle(case_name)\nfindExtrema(yyg, zg, psiPlot, max_lat=-30.)\nfindExtrema(yyg, zg, psiPlot, min_lat=25., min_depth=250.)\nfindExtrema(yyg, zg, psiPlot, min_depth=2000., mult=-1.)\nplt.gca().invert_yaxis()\n# create dataset to store results\nmoc = xr.Dataset(data_vars={ 'moc' :    (('z_l','yq'), psiPlot),\n                            'amoc' :   (('z_l','yq'), np.zeros((psiPlot.shape))),\n                            'moc_FFM' :   (('z_l','yq'), np.zeros((psiPlot.shape))),\n                            'moc_GM' : (('z_l','yq'), np.zeros((psiPlot.shape))),\n                            'amoc_45' : (('time'), np.zeros((ds_ann.time.shape))),\n                            'moc_GM_ACC' : (('time'), np.zeros((ds_ann.time.shape))),\n                            'amoc_26' : (('time'), np.zeros((ds_ann.time.shape))) },\n                            coords={'z_l': ds.z_l, 'yq':ds.yq, 'time':ds_ann.time})\nattrs = {'description': 'MOC time-mean sections and time-series', 'unit': 'Sv', 'start_date': avg['start_date'],\n       'end_date': avg['end_date']}\nadd_global_attrs(moc,attrs)\nprint('Saving netCDF files...')\nif not os.path.isdir('ncfiles'):\n      os.system('mkdir -p ncfiles')\nmoc.to_netcdf('ncfiles/'+str(dcase.casename)+'_MOC.nc')\n## Atlantic MOC\nm6plot.setFigureSize([16,9],576,debug=False)\ncmap = plt.get_cmap('dunnePM')\nm = 0*basin_code; m[(basin_code==2) | (basin_code==4) | (basin_code==6) | (basin_code==7) | (basin_code==8)]=1\nci=m6plot.pmCI(0.,22.,2.)\nz = (m*Zmod).min(axis=-1); psiPlot = MOCpsi(VHmod, vmsk=m*np.roll(m,-1,axis=-2))*conversion_factor\npsiPlot = 0.5 * (psiPlot[0:-1,:]+psiPlot[1::,:])\nyy = grd.geolat_c[:,:].max(axis=-1)+0*z\nplotPsi(yy, z, psiPlot, ci, 'Atlantic MOC [Sv]')\nplt.xlabel(r'Latitude [$\\degree$N]')\nplt.suptitle(case_name)\nfindExtrema(yy, z, psiPlot, min_lat=26.5, max_lat=27., min_depth=250.) # RAPID\nfindExtrema(yy, z, psiPlot, min_lat=44, max_lat=46., min_depth=250.) # RAPID\nfindExtrema(yy, z, psiPlot, max_lat=-33.)\nfindExtrema(yy, z, psiPlot)\nfindExtrema(yy, z, psiPlot, min_lat=5.)\nplt.gca().invert_yaxis()\nmoc['amoc'].data = psiPlot\n### AMOC profile at 26N\ncatalog = intake.open_catalog(diag_config_yml['oce_cat'])\nrapid_vertical = catalog[\"moc-rapid\"].to_dask()\nif 'zl' in ds:\n  zl=ds.zl.values\nelif 'z_l' in ds:\n  zl=ds.z_l.values\nelse:\n  raise ValueError(\"Dataset does not have vertical coordinate zl or z_l\")\nfig, ax = plt.subplots(nrows=1, ncols=1, figsize=(8, 6))\nax.plot(rapid_vertical.stream_function_mar.mean('time'), rapid_vertical.depth, 'k', label='RAPID')\nax.plot(moc['amoc'].sel(yq=26, method='nearest'), moc.z_l, label=case_name)\nax.legend()\nplt.gca().invert_yaxis()\nplt.grid()\nax.set_xlabel('AMOC @ 26N [Sv]')\nax.set_ylabel('Depth [m]');\n## AMOC time series\ndtime = ds_ann.time.values\n\namoc_26 = np.zeros(len(dtime))\namoc_45 = np.zeros(len(dtime))\nmoc_GM_ACC = np.zeros(len(dtime))\n\n# loop in time\nfor t in range(len(dtime)):\n    tmp = np.ma.masked_invalid(ds_ann[varName].sel(time=dtime[t]).values)\n    tmp = tmp[:].filled(0.)\n    psi = MOCpsi(tmp, vmsk=m*np.roll(m,-1,axis=-2))*conversion_factor\n    psi = 0.5 * (psi[0:-1,:]+psi[1::,:])\n    amoc_26[t] = findExtrema(yy, z, psi, min_lat=26.5, max_lat=27., plot=False)\n    amoc_45[t] = findExtrema(yy, z, psi, min_lat=44., max_lat=46., plot=False)\n    tmp_GM = np.ma.masked_invalid(ds_ann['vhGM'][t,:].values)\n    tmp_GM = tmp_GM[:].filled(0.)\n    psiGM = MOCpsi(tmp_GM)*conversion_factor\n    psiGM = 0.5 * (psiGM[0:-1,:]+psiGM[1::,:])\n    moc_GM_ACC[t] = findExtrema(yyg, zg, psiGM, min_lat=-65., max_lat=-30, mult=-1., plot=False)\n# add dataarays to the moc dataset\nmoc['amoc_26'].data = amoc_26\nmoc['amoc_45'].data = amoc_45\nmoc['moc_GM_ACC'].data = moc_GM_ACC\n# load datasets from oce catalog\namoc_core_26 = catalog[\"moc-core2-26p5\"].to_dask()\namoc_pop_26  = catalog[\"moc-pop-jra-26\"].to_dask()\nrapid = catalog[\"transports-rapid\"].to_dask().resample(time=\"1Y\", \n                closed='left',keep_attrs=True).mean('time',keep_attrs=True)\n\namoc_core_45 = catalog[\"moc-core2-45\"].to_dask()\n\namoc_pop_45 = catalog[\"moc-pop-jra-45\"].to_dask()\n\n#list(catalog)\n### AMOC @ 26 $^o$ N\n# plot\nfig = plt.figure(figsize=(12, 6))\nplt.plot(np.arange(len(moc.time))+1958.5 ,moc['amoc_26'].values, color='k', label=case_name, lw=2)\n# core data\ncore_mean = amoc_core_26['MOC'].mean(axis=0).data\ncore_std = amoc_core_26['MOC'].std(axis=0).data\nplt.plot(amoc_core_26.time,core_mean, 'k', label='CORE II (group mean)', color='#1B2ACC', lw=1)\nplt.fill_between(amoc_core_26.time, core_mean-core_std, core_mean+core_std,\n  alpha=0.25, edgecolor='#1B2ACC', facecolor='#089FFF')\n# pop data\nplt.plot(np.arange(len(amoc_pop_26.time))+1958.5 ,amoc_pop_26.AMOC_26n.values, color='r', label='POP', lw=1)\n# rapid\nplt.plot(np.arange(len(rapid.time))+2004.5 ,rapid.moc_mar_hc10.values, color='green', label='RAPID', lw=1)\n#plt.plot(np.arange(len(rapid_filtered.time))+2004.5 ,rapid_filtered.values, color='green', label='RAPID', lw=1)\n\nplt.title('AMOC @ 26 $^o$ N', fontsize=16)\nplt.ylim(5,20)\nplt.xlim(1948,1958.5+len(moc.time))\nplt.xlabel('Time [years]', fontsize=16); plt.ylabel('Sv', fontsize=16)\nplt.legend(fontsize=13, ncol=2)\n### AMOC @ 45 $^o$ N\n# plot\nfig = plt.figure(figsize=(12, 6))\nplt.plot(np.arange(len(moc.time))+1958.5 ,moc['amoc_45'].values, color='k', label=case_name, lw=2)\n# core data\ncore_mean = amoc_core_45['MOC'].mean(axis=0).data\ncore_std = amoc_core_45['MOC'].std(axis=0).data\nplt.plot(amoc_core_45.time,core_mean, 'k', label='CORE II (group mean)', color='#1B2ACC', lw=1)\nplt.fill_between(amoc_core_45.time, core_mean-core_std, core_mean+core_std,\n  alpha=0.25, edgecolor='#1B2ACC', facecolor='#089FFF')\n# pop data\nplt.plot(np.arange(len(amoc_pop_45.time))+1958. ,amoc_pop_45.AMOC_45n.values, color='r', label='POP', lw=1)\n\nplt.title('AMOC @ 45 $^o$ N', fontsize=16)\nplt.ylim(5,20)\nplt.xlim(1948,1958+len(moc.time))\nplt.xlabel('Time [years]', fontsize=16); plt.ylabel('Sv', fontsize=16)\nplt.legend(fontsize=13, ncol=3)\n### Submesoscale-induced Global MOC\n# create a ndarray subclass\nclass C(np.ndarray): pass\n\nif 'vhml' in ds.variables:\n  varName = 'vhml'; conversion_factor = 1.e-9\nelse: raise Exception('Could not find \"vhml\" in file \"%s\"'%(args.infile+args.monthly))\n  \ntmp = np.ma.masked_invalid(ds_mean[varName].values)\ntmp = tmp[:].filled(0.)\nVHmod = tmp.view(C)\nVHmod.units = ds[varName].units\n\n# Global MOC\nm6plot.setFigureSize([16,9],576,debug=False)\naxis = plt.gca()\ncmap = plt.get_cmap('dunnePM')\nz = Zmod.min(axis=-1); psiPlot = MOCpsi(VHmod)*conversion_factor\npsiPlot = 0.5 * (psiPlot[0:-1,:]+psiPlot[1::,:])\n#yy = y[1:,:].max(axis=-1)+0*z\nyy = grd.geolat_c[:,:].max(axis=-1)+0*z\nci=m6plot.pmCI(0.,20.,2.)\nplotPsi(yy, z, psiPlot, ci, 'Global MOC [Sv] due to vhML', zval=[0.,-400.,-6500.])\nplt.xlabel(r'Latitude [$\\degree$N]')\nplt.suptitle(case_name)\nplt.gca().invert_yaxis()\nmoc['moc_FFM'].data = psiPlot\n### Eddy(GM)-induced Global MOC\n# create a ndarray subclass\nclass C(np.ndarray): pass\n\nif 'vhGM' in ds.variables:\n  varName = 'vhGM'; conversion_factor = 1.e-9\nelse: raise Exception('Could not find \"vhGM\" in file \"%s\"'%(args.infile+args.monthly))\n  \ntmp = np.ma.masked_invalid(ds_mean[varName].values)\ntmp = tmp[:].filled(0.)\nVHmod = tmp.view(C)\nVHmod.units = ds[varName].units\n\n# Global MOC\nm6plot.setFigureSize([16,9],576,debug=False)\naxis = plt.gca()\ncmap = plt.get_cmap('dunnePM')\nz = Zmod.min(axis=-1); psiPlot = MOCpsi(VHmod)*conversion_factor\npsiPlot = 0.5 * (psiPlot[0:-1,:]+psiPlot[1::,:])\nyy = grd.geolat_c[:,:].max(axis=-1)+0*z\nci=m6plot.pmCI(0.,20.,1.)\nplotPsi(yy, z, psiPlot, ci, 'Global MOC [Sv] due to GM')\nplt.xlabel(r'Latitude [$\\degree$N]')\nplt.suptitle(case_name)\nfindExtrema(yy, z, psiPlot, min_lat=-65., max_lat=-30, mult=-1.)\nplt.gca().invert_yaxis()\nmoc['moc_GM'].data = psiPlot\n### Sigma-2 space (to be implemented...)\nprint('Saving netCDF files...')\nmoc.to_netcdf('ncfiles/'+str(dcase.casename)+'_MOC.nc')\n# release workers\nclient.close(); cluster.close()", "params": {"sname": "placeholder-sname", "subset_kwargs": {}}}